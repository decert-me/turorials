# 以太坊核心概念

在开始进行以太坊智能合约或去中心化应用（DApp）开发之前，我们先对以太坊做一些介绍，本章会介绍一些以太坊的核心概念，帮助大家了解以太坊的工作原理。

## 以太坊概述

以太坊（Ethereum）是一个建立在区块链技术之上的去中心化应用平台。它允许任何人在平台上建立和使用通过区块链技术运行的去中心化应用（DApp）。
去中心化应用（DApp） 和我们现在互联网客户端/服务端架构（C/S架构）的应用不同，应用的后端是一个有N个节点计算机（矿工）组成的网络，如下图所示。

![image-20230302182352875](https://img.learnblockchain.cn/pics/20230302182354.png!/scale/50)



我们在平时使用的应用程序中看到的内容通常是由后端的服务器提供，请求也是发送到后端的服务器处理。比如，支付宝、京东等应用，所有的数据在为公司所有。

而在去中心化应用中，在前端，用户通过自己的钱包由自己的数据，在后端核心逻辑使用智能合约运行在区块链的上，实现去信任。

Dapp与客户端连接的节点，只是网络中的一份子，它不单独处理来自用户的请求（这个请求通常称之为“交易”），而是要把用户的请求广播到整个网络，待整个网络达成共识之后，整个请求才算处理完成。



## 智能合约

到底什么是智能合约呢？那就是以太坊上运行的程序，和其他程序一样，它也是由代码和数据组成的。智能合约中的数据也称为“状态”，因为整个区块链就是由所有数据的确定的一个状态机。

:::tip

智能合约的英文是smart contract，和人工智能（AI：Artificial Intelligence）所指的“智能” 没有关系，智能合约的概念最早由尼克·萨博提出，就是将法律条文写成可执行代码，让法律条文的执行中立化，这和区块链上的程序可以不被篡改地执行在理念上不谋而合，因此区块链引入了智能合约这个概念。
:::

以太坊智能合约是 “图灵完备”的，因此理论上我们可以用它来编写能做任何事情的程序。
智能合约现在的主要编程语言是Solidity和Vyper，Solidity更为成熟一些，本教程中的智能合约代码都是用Solidity编写，通常合约文件的扩展名是.sol 。下面就是一个简单的计数器合约。

```js title="counter.sol"
pragma solidity ^0.8.0;
contract Counter {
    uint counter;

    constructor() {
        counter = 0;
    }

    function count() public {
        counter = counter + 1;
    }
}
```

这段代码有一个类型为uint（无符号整数）名为“counter”的变量。counter变量的内容（值）就是该合约的状态。每当我们调用count()函数时，此智能合约的区块链状态将增加1，这个状态是对任何人都可见的。

在教程的后面，我们会进一步介绍智能合约开发，在[合约的代码组成](../solidity-basic/2_solidity_layout.md)一节，会进一步介绍这个合约代码构成。





## 账户

当我们把counter合约部署到链上之后，会用一个地址对它进行表示（称为合约地址），它是以太坊网络中一种帐户：`合约账户`。

账户在以太坊中是非常重要的概念，任何都离不开它，以太坊中有两类账户：

（1）**外部用户账户（EOAs）**——该类账户被公钥-私钥对控制（由人控制）。

（2）**合约账户**（CA：Contract Account ）——该类账户被存储在账户中的代码控制。

外部用户账户和合约账户，它们都是用同样的地址形式来表示，在 EVM 层面是一样的，地址形式为：0xea674fdde714fd979de3edf0f56aa9716b898ec8，是一个20字节的16进制数。


外部用户账户的地址是由私钥推倒出来的，合约账户的地址则由创建者的地址和nonce计算得到，延伸阅读[《以太坊合约地址是怎么计算出来的？》](https://learnblockchain.cn/2019/06/10/address-compute/) 。

它们还有一个不能忽视的区别：**只有外部用户账户可以发起交易（主动行为），合约账户只能被动地响应动作，并且所有的手续费  Gas  只能由外部账号支付**。



![image-20230302185311619](https://img.learnblockchain.cn/pics/20230302185313.png!/scale/50)

> 上图：绿色箭头表示发起交易，灰色表示消息调用



### 账户状态

账户状态有4个基本组成部分，不论账户类型是什么，都存在这4个组成部分：




![image-20230302184505732](https://img.learnblockchain.cn/pics/20230302184507.png)

> 上图表示了在智能合约账户的内容



外部用户账户和合约账户都可以有余额；合约账户使用代码管理所拥有的资金，外部用户账户则是用私钥签名来花费资金；合约账户存储了代码，外部用户账户则没有。



* **nonce** ：如果账户是一个外部用户账户，nonce代表从此账户地址发送的交易序号。如果账户是一个合约账户，nonce代表此账户创建的合约序号

  :::tip

  提示：以太坊中有两种nonce ， 一种是账号nonce——表示一个账号的交易数量；一种是工作量证明nonce——一个用于计算满足工作量证明的随机数。

  :::

* **balance**：此地址拥有以太币余额数量。单位是`Wei`，`1 ether`=`10^18 wei`，当向地址发送带有以太币的交易时，balance会随之改变。

ether和wei是以太坊中以太币的两种面额单位， 就像人民币的元和分，除此之外，还有一个常用的面额单位Gwei，用来给 Gas 定价，1 Gwei = `10^9 wei` 。

* **状态根**： **storageRoot** Merkle Patricia树的根节点哈希值。Merkle树会将此账户存储内容的哈希值进行编码，默认是空值。

* **codeHash**：此账户代码的哈希值。对于合约账户，就是合约代码被哈希计算之后的哈希值作为codeHash保存。对于外部用户账户，codeHash 是一个空字符串的哈希值。

以太坊的全局共享状态是由所有账户状态组成，它由账户地址和账户状态组成的映射存储在区块的状态树中，如图4-3所示。

![image-20230302185955720](https://img.learnblockchain.cn/pics/20230302185957.png)

> 以太坊全局状态

## 以太币的单位

以太币是一种货币，不同单位的货币就像法币中不同的面额，对于用户来讲，最常用的是ether，1个ether就是我们常说的一个以太币（通常也简称为以太），对于开发者来说可能最常用的是wei, 它是以太币的最小单位， 其他的单位包括finney、szabo，其中wei还有几个衍生的单位：Kwei、Mwei以及Gwei。
它们的换算关系是：

```
1 ether == 10^3 finney（即1000 finney）
1 ether == 10^6 szabo
1 ether == 10^18 wei
1 Gwei == 10^9 wei
1 Mwei == 10^6 wei
```

以太币的单位其实很有意思，以太坊社区为了纪念密码学家的贡献，使用密码学家的名字作为货币单位，就像很多国家的货币会印上对国家有卓越贡献的伟人头像一样。
wei名字来自于Wei Dai（戴伟），密码学家，发表了B-money。 
finney来自于Hal Finney（哈尔·芬尼），密码学家，提出了工作量证明机制（PoW）。
szabo来自于Nick Szabo（尼克·萨博），密码学家，智能合约的提出者。

##  以太坊虚拟机（EVM）

以太坊虚拟机（Ethereum Virtual Machine）， 简称EVM， 用来执行以太坊上的交易，提供智能合约的运行环境。
熟悉Java的同学，可以把EVM当做JVM来理解，EVM 同样是一个程序运行的容器。

以太坊虚拟机是一个被沙箱封装起来、完全隔离的运行环境， 只能访问内部信息。





##  以太坊客户端

以太坊客户端是以太坊网络中的节点程序， EVM 是节点程序重要的部分。

运行节点程序就可以加入的区块链网络中，成为一个节点。



以太坊在 TheMerge（合并）之后，分为了执行层和共识层：

执行层负责处理交易（EVM 执行），执行层客户端有：Geth（Go 实现）、Nethermind(C#实现)、Erigon（Go 实现） 。

共识层负责处理共识（出块），共识层客户端有：Prysm（Go）、Lighthouse（Rust 实现）



这个节点程序可以完成如创建账号、发起交易、部署合约、执行合约、挖掘区块等工作。
以太坊客户端由很多个编程语言的客户端版本实现，常用的为Geth和Parity。
Geth是以太坊官方社区开发的客户端，基于Go语言开发。Parity是Rust语言实现的客户端。开发者使用Geth更多，接下来介绍Geth的使用。Geth提供了一个交互式命令控制台， 我们可以在控制台中和以太坊网络进行交互。



而以太坊虚拟机本身运行在以太坊节点客户端上，各层关系如下图所示:



![image-20230306145536384](https://img.learnblockchain.cn/pics/20230306145537.png)



> EVM 与节点



所有用户通过节点与区块链网络交互，普通用户可以不用搭建节点，而且运行节点资源要就较高，目前有很多专业的节点服务商: [Infura](https://www.infura.io/zh), [alchemy](https://www.alchemy.com/) 可供选择。



##  钱包

钱包是账户管理工具，用户可以利用钱包创建账号，进行交易签名，签名动作在本地执行，当发起交易时，才需连接区块链节点。

:::tip

账户持有的资产均保存在链上，而不是在钱包里。
:::



普通用户用得较多的是App钱包：例如 ImToken、TrustWallet 等，开发者常用的钱包是 MetaMask 钱包，它是一个浏览器插件（支持Chrome 、Firefox、Opera等浏览器），它可以和Remix配合使用，用来部署和执行智能合约。



可以在[MetaMask](https://metamask.io)网站，找到对应的插件来安装，安装完成经过账号导入或创建之后，可以看到MetaMask的界面:

![](https://img.learnblockchain.cn/pics/20230302190713.png)

> MetaMask界面截图



## Gas  

前面提到，在EVM上运行的智能合约是 “图灵完备”的，理论上可以编写能做任何事情的程序。既然如此，恶意的执行者就可以通过执行一个包含无限循环的交易轻易地让网络瘫痪。

以太坊通过每笔交易收取一定的费用来保护网络不受蓄意攻击，这一套收费的机制称为 Gas 机制。

 Gas 是衡量一个操作或一组操作需要执行多少” 工作量” 单位。例如，计算一个Keccak256加密哈希函数，每次计算哈希时需要30个 Gas ，再加上每256位被哈希的数据要花费6个 Gas 。EVM上执行的每个操作都会消耗一定数量的 Gas ，而需要更多计算资源的操作也会消耗更多的 Gas 。

>  可以把 Gas 看做是以太坊虚拟机的运行燃料，它在每执行一步的时候消耗一定的 Gas ， 如果给定的 Gas 不够，无论执行到什么位置，，将会触发一个 out-of- gas 异常，当前交易所作的所有状态修改都将被还原。

如果 Gas 仅仅是一个“工作量”单位，那怎么支付费用呢？还有另一个概念—— Gas 价格（ `Gas  price`）。其实每笔交易都要指定预算 Gas （Gas limit）及愿意为单位 Gas 支付的 Gas 价格，这是两者的结合， `Gas 预算` *  `Gas 价格` = 交易预算。



`gas limit` > `实际使用的 gas` ， 交易才能顺利执行， 否则触发`out of gas` 交易回滚， 如果执行结束还有Gas剩余，这些Gas将被返还给发送交易账户。这也是称为交易预算的原因，由于链上状态的不断更新，很多时候无法完全准确测算交易费用，在实际提交交易时， `gas limit` 通常开发工具估算，`gas price` 用户指定（钱包提供参考值）， 矿工通过gas price 对交易排序。



> 在EIP1559 之前，手续费都是矿工收取， EIP1559 base fee 被燃烧。小费（tip） priority Fee 矿工收取，用户在设置 price 也更复杂一些， 可参考：[EIP1559下的 GAS 费设置解析](https://learnblockchain.cn/article/3550)



Gas 价格是用以太币（wei/gwei为单位）来表示。



0x63be89f739f7dcbed6f9fb69b748e58c8ad33e89d2b758f14e76f233c95812ba



## 以太坊交易

我们知道，比特币交易非常简单，它只做一件事，就是进行货币的转移。可以归纳为TO（谁收钱），FROM（谁汇款）和 AMOUNT（多少钱）。

以太坊与之很大的不同在于其交易还有一个DATA字段。 DATA字段支持三种类型的交易：

1. **普通交易：**

   * TO ：收款地址

   * FROM ：谁发出

   * AMOUNT ：发送多少

   * DATA ：留空或留言信息

2. **创建合约**

   * TO ：留空（这就是触发创建智能合约的原因）

   * FROM ：谁创建

   * AMOUNT ：可以是0或任何数量的以太币，它是我们想要给合约的存款

   * DATA ：包含编译为字节码的智能合约代码

3. **调用合约函数**

   * TO： 目标合约账户地址
   * DATA： 包含函数名称和参数——标识如何调用智能合约函数
   * FROM ：谁调用
   * AMOUNT ： 可以是0或任意数量的以太币，例如可以支付给合约的服务费用

   

   虽然实际交易有更多复杂的细节，但核心概念就是这些。
   让我们看一些具体的例子，说明这些交易长什么样，尤其是通过DATA来理解合约调用。

###  普通交易

```json
{
to: '0x687422eEA2cB73B5d3e242bA5456b782919AFc85',
value: 0.0005,
data: "0x" // 也可以附加消息
}
```


非常简单，就是转移一定数量的以太币到某个地址，如果我们愿意也可以向交易添加消息。

###  创建智能合约

```json
{
  to: '',
  value: 0.0,
  data: "0x6060604052341561000c57xlb60405160c0806……………"
}
```


如上所述，TO为空表示创建智能合约，DATA 为创建智能合约的字节码。

### 调用合约方法

```json
{
  to: '0x687422eEA2cB73B5d3e242bA5456b782919AFc85’, //合约地址
  value: 0.0,
  data: "0x06661abd"
}
```



函数调用信息封装在DATA字段中，把这个交易信息发送到要调用的智能合约的地址。假设我们要调用前面的`count()`函数，传递的是 `count()`函数的选择器。


如果你刚接触合约开发，本节内容可能有些不容易，没有关系，可以在学习实践一段时间后，会过头再来看看。
